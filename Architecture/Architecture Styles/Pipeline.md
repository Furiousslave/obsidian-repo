# Topology
The topology of the pipeline architecture consists of pipes and filters, illustrated.
![[Pasted image 20240407161715.png]]

The pipes and filters coordinate in a specific fashion, with pipes forming one-way communication between filters, usually in a point-to-point fashion.
## Pipes
_Pipes_ in this architecture form the communication channel between filters. Each pipe is typically unidirectional and point-to-point (rather than broadcast) for performance reasons, accepting input from one source and always directing output to another. The payload carried on the pipes may be any data format, but architects favor smaller amounts of data to enable high performance.
## Filters
_Filters_ are self-contained, independent from other filters, and generally stateless. Filters should perform one task only. Composite tasks should be handled by a sequence of filters rather than a single one.
Four types of filters exist within this architecture style:
- **Producer**: The starting point of a process, outbound only, sometimes called the _source_.
- **Transformer**: Accepts input, optionally performs a transformation on some or all of the data, then forwards it to the outbound pipe. Functional advocates will recognize this feature as _map_.
- **Tester**: Accepts input, tests one or more criteria, then optionally produces output, based on the test. Functional programmers will recognize this as similar to _reduce_.
- **Consumer**: The termination point for the pipeline flow. Consumers sometimes persist the final result of the pipeline process to a database, or they may display the final results on a user interface screen.
# Example
The pipeline architecture pattern appears in a variety of applications, especially tasks that facilitate simple, one-way processing. For example, many Electronic Data Interchange (EDI) tools use this pattern, building transformations from one document type to another using pipes and filters. ETL tools (extract, transform, and load) leverage the pipeline architecture as well for the flow and modification of data from one database or data source to another. Orchestrators and mediators such as [Apache Camel](https://camel.apache.org/) utilize the pipeline architecture to pass information from one step in a business process to another.

To illustrate how the pipeline architecture can be used, consider the following example, as illustrated, where various service telemetry information is sent from services via streaming to [Apache Kafka](https://kafka.apache.org/).
![[Pasted image 20240407162212.png]]
Notice in figure the use of the pipeline architecture style to process the different kinds of data streamed to Kafka. The `Service Info Capture` filter (producer filter) subscribes to the Kafka topic and receives service information. It then sends this captured data to a tester filter called `Duration Filter` to determine whether the data captured from Kafka is related to the duration (in milliseconds) of the service request. Notice the separation of concerns between the filters; the `Service Metrics Capture` filter is only concerned about how to connect to a Kafka topic and receive streaming data, whereas the `Duration Filter` is only concerned about qualifying the data and optionally routing it to the next pipe. If the data is related to the duration (in milliseconds) of the service request, then the `Duration Filter` passes the data on to the `Duration Calculator` transformer filter. Otherwise, it passes it on to the `Uptime` tester filter to check if the data is related to uptime metrics. If it is not, then the pipeline ends—the data is of no interest to this particular processing flow. Otherwise, if it is uptime metrics, it then passes the data along to the `Uptime Calculator` to calculate the uptime metrics for the service. These transformers then pass the modified data to the `Database Output` consumer, which then persists the data in a [MongoDB](https://www.mongodb.com/) database.

This example shows the extensibility properties of the pipeline architecture. For example, in figure, a new tester filter could easily be added after the `Uptime` to pass the data on to another newly gathered metric, such as the database connection wait time.
# Architecture Characteristics Ratings
![[Pasted image 20240407162307.png]]
The pipeline architecture style is a technically partitioned architecture due to the partitioning of application logic into filter types (producer, tester, transformer, and consumer). **Also, because the pipeline architecture is usually implemented as a monolithic deployment, the architectural quantum is always one**.

**Overall cost and simplicity combined with modularity are the primary strengths of the pipeline architecture style**. Being monolithic in nature, pipeline architectures don’t have the complexities associated with distributed architecture styles, are simple and easy to understand, and are relatively low cost to build and maintain. **Architectural modularity is achieved through the separation of concerns between the various filter types and transformers**. Any of these filters can be modified or replaced without impacting the other filters. For instance, in the Kafka example illustrated in [Figure 11-2](httpsr2://id_qzpc_v_x_nlcn_nc_tmlra_x_rh_x_e_fwc_e_rhd_g_fc_um9hb_wlu_z1x_f_r_f_j_m_y_w_iu_v_ghvcml1b_v_jl_y_w_rlclxwd_w_jsa_w_nhd_glvbn_nc_mzk1_ym_nk_y_w_ut_zjll_o_c00_nj_zl_l_tkw_o_g_et_nm_ri_o_t_m5_nm_ri_o_d_bh_x_g_jvb2su_z_x_b1_yg--/xthoriumhttps/ip0.0.0.0/p/OEBPS/ch11.xhtml?r2_CSS=eyJzZXRDU1MiOnsiYTExeU5vcm1hbGl6ZSI6ZmFsc2UsImJvZHlIeXBoZW5zIjoiYXV0byIsImNvbENvdW50IjoiYXV0byIsImZvbnQiOiJERUZBVUxUIiwiZm9udFNpemUiOiIxMzcuNSUiLCJpbnZlcnQiOmZhbHNlLCJsZXR0ZXJTcGFjaW5nIjoiMCIsImxpZ2F0dXJlcyI6Im5vbmUiLCJsaW5lSGVpZ2h0IjoiMCIsIm5pZ2h0IjpmYWxzZSwicGFnZU1hcmdpbnMiOiIwLjUiLCJwYWdlZCI6dHJ1ZSwicGFyYVNwYWNpbmciOiIwIiwic2VwaWEiOmZhbHNlLCJ3b3JkU3BhY2luZyI6IjAiLCJtYXRoSmF4IjpmYWxzZSwicmVkdWNlTW90aW9uIjpmYWxzZSwibm9Gb290bm90ZXMiOmZhbHNlLCJub1J1YnkiOmZhbHNlfX0%3D&r2_ERS=eyJuYW1lIjoiVGhvcml1bSIsInZlcnNpb24iOiIyLjQuMSJ9&r2_DEBUG=false&r2_CLIPBOARD_INTERCEPT=false&r2_WEBVIEW_SLOT=center&r2_SECOND_WEBVIEW=0&r2_SESSION_INFO=MjZjYWE0NzctY2RkOC00YmI1LTlkZGQtM2M0NzdjMjM5YzUx#fig-style-pipeline-example), the `Duration Calculator` can be modified to change the duration calculation without impacting any other filter.

**Deployability and testability, while only around average, rate slightly higher than the layered architecture due to the level of modularity achieved through filters**. That said, this architecture style is still a monolith, and as such, ceremony, risk, frequency of deployment, and completion of testing still impact the pipeline architecture.

Like the layered architecture, **overall reliability rates medium (three stars) in this architecture style, mostly due to the lack of network traffic, bandwidth, and latency found in most distributed architectures**. We only gave it three stars for reliability because of the nature of the monolithic deployment of this architecture style in conjunction with testability and deployability issues (such as having to test the entire monolith and deploy the entire monolith for any given change).

**Elasticity and scalability rate very low (one star) for the pipeline architecture, primarily due to monolithic deployments**. Although it is possible to make certain functions within a monolith scale more than others, this effort usually requires very complex design techniques such as multithreading, internal messaging, and other parallel processing practices, techniques this architecture isn’t well suited for. However, because the pipeline architecture is always a single system quantum due to the monolithic user interface, backend processing, and monolithic database, applications can only scale to a certain point based on the single architecture quantum.

**Pipeline architectures don’t support fault tolerance due to monolithic deployments and the lack of architectural modularity**. If one small part of a pipeline architecture causes an out-of-memory condition to occur, the entire application unit is impacted and crashes. Furthermore, overall availability is impacted due to the high mean time to recovery (MTTR) usually experienced by most monolithic applications, with startup times ranging anywhere from 2 minutes for smaller applications, up to 15 minutes or more for most large applications.