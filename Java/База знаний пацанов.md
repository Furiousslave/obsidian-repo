## JVM, JRE, JDK

![](https://lh7-us.googleusercontent.com/8rbjcACEtmupGngJUB97Mvm6wE4Yrb8N_DealroGDRUEeJOPnwThcXikvugAYXfz3P0U5kJqqIlVCwJqXK2YqGrDjORLMF6D889u5FZp1ZDr5sTRk5SoQ6FH33ElUk-q3xSStQBzBZlIYgqC1cP7Mos)

  

JVM (Java Virtual Machine) - Виртуальная машина отвечает за само выполнение кода. Она работает с байткодом (тем, что находится внутри файлов с расширением .class).

  

JRE (Java Runtime Environment) - окружение, необходимое для запуска Java-программ. Включает в себя стандартную библиотеку. В нее входят, как базовые пакеты lang, util, так и пакеты для работы с различными форматами, базами данных, пользовательским интерфейсом. JVM тоже часть JRE.

  

JDK (Java Development Kit) - набор программ для разработки. Именно его мы (или редактор) устанавливаем к себе на компьютер, чтобы заниматься разработкой на Java. Он включает в себя JRE, загрузчик кода java, компилятор javac, архиватор jar, генератор документации javadoc и другие утилиты, нужные во время разработки.

  

Вендоры используют свои реализации JVM (Oracle - Hotspot).

JVM поставляется в двух вариантах: client и server (быстрее, но дольше запускается и требует больше памяти во время выполнения). Для выбора режима опции: -client и -server.

![](https://lh7-us.googleusercontent.com/muA211Qz08lY9my7eBah8FeSH_ZcoNmO2Cu0hWCHd9mcXN4R62xnNxSY_lgpaz-vjFUkY7vhZHLveTuPxan_DVUwILa1pPMryC6EJxPs4y4iJi12YOjx1Uq86ioKzqxzGf5Wb0Uy8HLJiwzN3WqAlJI)

## CLASSPATH

Classpath - набор путей, по которым компилятор Java и JVM должны находить необходимые классы для компиляции или выполнения других классов.

Classpath устанавливается параметром либо в переменную среды CLASSPATH, либо при запуске приложения параметром -classpath (-cp)

Он может указывать на:

- JAR/ZIP
    
- Пути к вершине иерархии пакетов. (например если мы импортим com.test.loh.LohClass, а всё это расположено C:\Users\HP\Projects/com/test/loh/LohClass, classpath был бы C:\Users\HP\Projects) 
    

## CLASSLOADERS

Class Loader - подсистема для загрузки .class файлов, выполняющая 3 функции:

1. loading 
    
2. linking
    
3. initialization
    

### Стадии работы

#### Loading

Стадия работы Class Loader, на которой происходит поиск и импорт ресурсов (конфиги, изображение и т.п.), бинарных данных для типа по его имени, создание класса / интерфейса из этого бинарного представления.

Перед тем как делегировать загрузку родителю, ClassLoader ищет класс в своем кэше, в котором он будет лежать, если загружался ранее.

#### Linking 

Стадия, на которой выполняется:

1. Verification -  проверка правильности байт-кода загружаемого класса (Если не пройдет проверку кинет VerifyError)
    
2. Preparation - выделение памяти для статических переменных и методов класса, а также инициализация значений по умолчанию
    
3. Resolution - преобразование символьных ссылок типов в прямые ссылки.
    

#### Initialization 

На этом этапе происходит вызов кода, который инициализирует статические переменные их указанными значениями, а также выполнение статических блоков.

  

Используется модель делегирования загрузки классов: у каждого ClassLoader есть родительский ClassLoader, которому он сначала делегирует поиск класса и если тот не находит - ищет сам.

  

### Типы classloader’ов

![](https://lh7-us.googleusercontent.com/vHZSB-v9jgIqVl8ySMgi8zJO-iuKp7mbKFdXjNZ8QlvrO23Ts7kSgl5lf39G9X-mvX-eUAfo5rNutnER0QtoHvfJQ45ACao_7B7ZVox8ml57E5g7NE_CPWVprTlMZynJSY_dexy6U9xcQO0kysT9nj8)

#### Bootstrap 

Реализован на уровне JVM и не имеет обратной связи со средой исполнения. Данным загрузчиком загружаются необходимые классы из директории $JAVA_HOME/lib. Т.е. всеми любимый rt.jar загружается именно базовым загрузчиком. Поэтому, попытка получения загрузчика у классов java.* всегда заканчиватся null'ом. Это объясняется тем, что все базовые классы загружены базовым загрузчиком, доступа к которому из управляемой среды нет.

#### Application CL (System CL) 

Родительский класс для новых загрузчиков, использующийся для загрузки классов приложения из classpath 

#### Extension CL (Platform CL в java 9+)

java 8 и ниже: загружает расширения основных классов Java (из директории /lib/ext)

java 9+: механизм extension был удален. Видны все классы платформы Java SE

## MEMORY

![](https://lh7-us.googleusercontent.com/0JfpG_X46RLfGdfBkMFFgqh4f_XYoqxSWg8AvVdrb42Ti-rQBwvup4I1d336GhjGhn46onOZkTWutUB6fbupSx94LCMlm3gNpiLaNQ3nr-54Alb6wdExHWxfQ0cDWbJ0eU8iJ_6wsqvbYwWB9LGQmBM)

Структура памяти Java

Native Memory — вся доступная системная память.

Heap (куча) — часть native memory, выделенная для кучи. Здесь JVM хранит объекты. Это общее пространство для всех потоков приложения. Размер этой области памяти настраивается с помощью параметра -Xms (минимальный размер) и -Xmx (максимальный размер).

Stack (стек) — используется для хранения локальных переменных и стека вызовов метода. Для каждого потока выделяется свой стек. Один фрейм выделяется для одного потока, следовательно, потокобезопасна.

Состоит из 3 частей:

- Local Variable Array - содержит локальные переменные и параметры метода
    
- Operand Stack - хранит результаты промежуточных вычислений
    
- Frame Data - хранит частичные результаты возвращаемых значений для методов и ссылки на Exception table, содержащую информацию о catch блоке.
    

Если выделенный frame переполняется, то бросается StackOverflow.

Metaspace (метаданные) — в этой памяти хранятся метаданные классов и статические переменные. Это пространство также является общими для всех. Так как metaspace является частью native memory, то его размер зависит от платформы. Верхний предел объема памяти, используемой для metaspace, можно настроить с помощью флага MaxMetaspaceSize.

PermGen (Permanent Generation, постоянное поколение) присутствовало до Java 7. Начиная с Java 8 ему на смену пришла область Metaspace.

CodeCache (кэш кода) — JIT-компилятор компилирует часто исполняемый код, преобразует его в нативный машинный код и кеширует для более быстрого выполнения. Это тоже часть native memory.

## Execution Engine

Execution engine - компонент JVM, исполняющий байт-код, который нужно выполнить в runtime data areas, полученный от classloader’а. Т.к. байт-код Java написан в человеко-читаемой форме, execution engine должен конвертировать его на язык, понятный JVM.

Состоит из 3 компонентов:

### Interpreter

Считывает инструкции байт-кода и последовательно их выполняет. Недостатком является то, что при многократном вызове одного метода требует вызов интерпретатора снова. Для решения этого недостатка используется JIT Compiler.

### JIT Compiler

JIT (Just-In-Time) Compiler - компилирует байт-код часто вызываемых методов в нативный код. JVM отслеживает, какие методы выполняются и как только метод становится готовым к компиляции, он назначается для компиляции в машинный код. Такой метод называется hot method. 

* Компиляция происходит в отдельном JVM потоке.

* Oracle использует Hotspot Compiler

### Garbage Collector

Компонент, обеспечивающий процесс сборки мусора, заключающийся в определении того, какие объекты в runtime data area не используются (никто на них не ссылается), и последующим их удалением.

### Процесс сборки мусора

Для сборки мусора используется алгоритм пометок (Mark & Sweep). Этот алгоритм состоит из трех этапов:

1. Mark (маркировка). На первом этапе GC сканирует все объекты и помечает живые (объекты, которые все еще используются). На этом шаге выполнение программы приостанавливается. Поэтому этот шаг также называется "Stop the World" .
    
2. Sweep (очистка). На этом шаге освобождается память, занятая объектами, не отмеченными на предыдущем шаге.
    
3. Compact (уплотнение). Объекты, пережившие очистку, перемещаются в единый  непрерывный блок памяти. Это уменьшает фрагментацию кучи и позволяет проще и быстрее размещать новые объекты.
    

![Mark & Sweep GC](https://lh7-us.googleusercontent.com/woTQHQ4z3wUH94syIgujxj-9cV1JlR-P2NPbQDEGlN3s5S4TaGPE8mcHrrfhs1rjtqf1RcCnhNqsP1Z7tFsOnQZ5F8vhrlIbtipm876bhrawTgKsGUJ4HYxGuJuX2k8rDF6kshefGzG4-pFmljQ0oxE "Mark & Sweep GC")

Поколения объектов

Для оптимизации сборки мусора память кучи дополнительно разделена на четыре области. В эти области объекты помещаются в зависимости от их возраста (как долго они используются в приложении).

1. Young Generation (молодое поколение). Здесь создаются новые объекты. Область young generation разделена на три части раздела: Eden (Эдем), S0 и S1 (Survivor Space — область для выживших).
    
2. Old Generation (старое поколение). Здесь хранятся давно живущие объекты.
    

![Поколения в куче](https://lh7-us.googleusercontent.com/hEo2fr8oMADQqTqw0YNueNDXwshXVa1uuaCgwrCWgrHMK-8vaWaST6kBHBQEkFKrFJNv6zmdDrhCPiqk_FDSb4wD_4cvBns9JHqG6N2Q-D0GDvqmJVxKb_6mE52B2j1LG0jUOwR2M3KFYw7G3S1LDbo "Поколения в куче")

Stop the world

Когда запускается этап mark, работа приложения останавливается. После завершения mark приложение возобновляет свою работу. Любая сборка мусора — это "Stop the World".

Что такое гипотеза о поколениях?

Как уже упоминалось ранее, для оптимизации этапов mark и sweep используются поколения. Гипотеза о поколениях говорит о следующем:

1. Большинство объектов живут недолго.
    
2. Если объект выживает, то он, скорее всего, будет жить вечно.
    
3. Этапы mark и sweep занимают меньше времени при большом количестве мусора. То есть маркировка будет происходить быстрее, если анализируемая область небольшая и в ней много мертвых объектов.
    

Таким образом, алгоритм сборки мусора, использующий поколения, выглядит следующим образом:

![Сборка мусора поколениями](https://lh7-us.googleusercontent.com/E-eYAuBp0-eZblgKlXpFsZMxN5tN99TmFLHGL_Sr1OU2UnKccddVsVYnmLuFA2ITvxCeGi1ddZgmGrOc3ipXsqVQf0-fR4AUsbl6n-dJZ_D_A3zBV9X3YKiQ8BFv76yQJ6veR5qdcRDnWleaECMaHwg "Сборка мусора поколениями")

1. Новые объекты создаются в области Eden. Области Survivor (S0, S1) на данный момент пустые.
    
2. Когда область Eden заполняется, происходит минорная сборка мусора (Minor GC). Minor GC — это процесс, при котором операции mark и sweep выполняются для young generation (молодого поколения).
    
3. После Minor GC живые объекты перемещаются в одну из областей Survivor (например, S0). Мертвые объекты полностью удаляются.
    
4. По мере работы приложения пространство Eden заполняется новыми объектами. При очередном Minor GC области young generation и S0 очищаются. На этот раз выжившие объекты перемещаются в область S1, и их возраст увеличивается (отметка о том, что они пережили сборку мусора).
    
5. При следующем Minor GC процесс повторяется. Однако на этот раз области Survivor меняются местами. Живые объекты перемещаются в S0 и у них увеличивается возраст. Области Eden и S1 очищаются.
    
6. Объекты между областями Survivor копируются определенное количество раз (пока не переживут определенное количество Minor GC) или пока там достаточно места. Затем эти объекты копируются в область Old.
    
7. Major GC. При Major GC этапы mark и sweep выполняются для Old Generation. Major GC работает медленнее по сравнению с Minor GC, поскольку старое поколение в основном состоит из живых объектов.
    

Преимущества использования поколений

Minor GC происходит в меньшей части кучи (~ 2/3 от кучи). Этап маркировки эффективен, потому что область небольшая и состоит в основном из мертвых объектов.

Недостатки использования поколений

В каждый момент времени одно из пространств Survivor (S0 или S1) пустое и не используется.

---

# Collection API

![](https://lh7-us.googleusercontent.com/Ag4LD4dN_hlHwSMV49OJ7WnKMK9-rw7-klSqxhUqJ_sI6PCpoCo8JyQVNGmguSQHKfuaC9uh6RzFZea7QdcvrjQS0AXEiN8z1O8R7sjveYQ_Iq007S-_s7Lm9Qpiz4PCIVE4gDRpwHb0g3ETBUEJ1Pk)

![](https://lh7-us.googleusercontent.com/91yEzd2LUEHybz4OI9tgtq-IILDXJA1j8SB9kMoe5nvzNxkwTZISbj1WFQzMtlwFbx384_gGThkFdSnYK1RzXCJHXEpqAzggQqZ1FN72L7oFog6zaoRTo8dSLbgupUgy5dFdBs3ewA1pa9y2chdCi5U)

## Iterable

Классы, реализующие Iterable, могут быть проитерированы в for-each цикле, forEach методе и при помощи Iterator.

- iterator() - возвращает объект Iterator
    
- forEach(Consumer<> action) - выполняет заданное действие над элементами во время итерирования по ним
    
- spliterator() - создает объект Spliterator над элементами
    

### Iterator

Интерфейс, предоставляющий методы, реализации которых должны использоваться для итерации по коллекции элементов

- hasNext(): возвращает true, если есть следующий элемент. Используется как условие в цикле
    
- next(): перемещает итератор вперед и возвращает элемент
    
- remove(): удаляет последний вернувшийся из next() элемент
    
- forEachRemaining(Consumer<> action):выполняет заданное действие над элементами во время итерирования по ним
    

### ListIterator

Наследник Iterator, расширяющий его функционал для перебора списков

- hasPrevious() и previous() - аналогично hasNext() и next(), но для предыдущего элемента
    
- nextIndex() и previousIndex() - возвращает индекс следующего или предыдущего элемента соответственно
    
- set(E element) - устанавливает элемент вместо полученного последним вызовом методов next / previous
    
- add(E element) - вставляет элемент после полученного методом next или перед полученным методов previous
    

### [Spliterator](https://habr.com/ru/post/256905/)

Интерфейс, использующийся в реализации Stream API и Collection API для итерирования по потокам / коллекциям с поддержкой разделения потоков для параллельных операций над источником данных. Кроме того, сплитератор не модифицирует источник данных, т.к. не имеет метода remove, как итератор.

- tryAdvance(Consumer) — объединение методов итератора hasNext() и next(). Если у сплитератора есть следующий элемент, он должен вызвать переданную функцию с этим элементом и вернуть true, иначе функцию не вызывать и вернуть false.
    
- trySplit() — попытаться поделиться надвое. Метод возвращает новый сплитератор, который будет пробегать по первой половине исходного набора данных, при этом сам текущий сплитератор перепрыгивает на вторую половину.
    
- characteristics() — возвращает битовую маску характеристик сплитератора (ORDERED, DISTINCT, SIZED, SORTED, SUBSIZED, NONNULL, IMMUTABLE, CONCURRENT)
    
- estimateSize() — метод должен возвращать количество оставшихся элементов для SIZED-сплитераторов и как можно более точную оценку в остальных случаях.
    

## [List](https://javarush.com/groups/posts/2472-podrobnihy-razbor-klassa-arraylist)

Данный интерфейс предоставляет методы получения, добавления, изменения и удаления элемента по индексу и др.

### ArrayList

Представляет собой реализацию динамического массива, данные которого хранятся в обычном массиве. По умолчанию при создании ArrayList внутренний массив инициализируется с размером 10.

Vector аналогичен ArrayList, но потокобезопасен.

  

Механизм добавления элемента

1. Производится проверка на заполненность массива и если он заполнен, то создается новый массив с capacity = (oldCapacity 1.5)+1 (+1 - для добавляемого элемента).
    
2. Элементы копируются в новый массив при помощи Arrays.copyOf() метода, который внутри себя вызывает System.arraycopy() - очень быстрый нативный метод (написанный на С/С++), копирующий массив блоками памяти, а не поэлементно
    

  

Основные операции:

- Получение по индексу: O(1) (обращение по индексу массива)
    
- Вставка: O(n). Чем ближе вставляемый элемент к началу массива, тем выше сложность, т.к. приходится сдвигать последующие элементы вправо путем копирования. 
    
- Удаление: O(n). Аналогично вставке, но последующие элементы переносятся влево.
    

### LinkedList

Является реализацией АТД двусвязный список: каждый элемент хранится как объект Node, содержащий значение элемента и ссылки на соседние node’ы. 

LinkedList хранит указатели на первый и последний node, от которых он может производить операции.

  

Основные операции:

- Получение по индексу: O(n). Для получения по индексу происходит проход по всем node’ам по очереди (при этом если индекс ближе к началу, то поиск идет с 1 элемента, иначе с последнего и по факту худший проход - по половине списка, если вставка в середину)
    
- Вставка: O(1) - если в начало или в конец и O(n) - если по индексу (потому что сначала нужно найти соседний node по индексу). Для непосредственно вставки элемента изменяются ссылки у двух его соседей.
    
- Удаление: аналогично вставке
    

### Сравнение ArrayList и LinkedList

1. LinkedList быстрее ArrayList’а только в операции вставки элемента в начало
    
2. Элемент в LinkedList занимает ~ в 3 раза больше памяти, поскольку помимо ссылки на сам элемент хранит еще две ссылки на соседей (в 32bit ссылка занимает 4 байта)
    

### Stack

Реализация АТД Стек, работающей по принципу LIFO (Last In First Out). Предоставляет 5 методов относительно Vector (ArrayList):

1. push - добавление элемента на вершину стека
    
2. pop - удаляет элемент с вершины и возвращает его
    
3. peek - возвращает элемент с вершины (аналог getLast)
    
4. empty - возвращает true, если стек пуст
    
5. search - возвращает расстояние от вершины стека до переданного элемента и -1, если переданный элемент не найден
    

## Queue

![](https://lh7-us.googleusercontent.com/rsoaWAZe6wpqncxfaGcjJy60kEY3GTTeuIi26aXTz5Rqbm5kobObHKfT1Ra1sd_sAwDIb9L0881uVD96U76sWLb6ZjV-qlyfxL3_-GPGUz_bm1v8FNi_f_JybSkskZ1Ne1HwHbE7EWpdDfo7mmzq18A)

Представляет АТД Очередь, работающую по принципу FIFO (First In First Out), реализации которой должны имплементировать следующие методы:

1. add & offer - добавляют элемент в хвост очереди и возвращают true, если добавился.  
    add бросает IllegalStateException если элемент не может быть добавлен, а offer - возвращает false.
    
2. remove & poll - удаляют элементы из головы очереди.  
    remove бросает NoSuchElementException, если очередь была пуста, а poll в этом случае вернет null
    
3. element & peek - возвращают элемент из головы очереди и не удаляет его.  
    element бросает NoSuchElementException, если очередь пуста, а peek - null  
      
    

LinkedList реализует Queue

### PriorityQueue

Реализация очереди с приоритетом, основанная на массиве. 

- Дефолтный capacity = 11
    
- Порядок элементов определяется компаратором при создании очереди
    
- Не допускаются null-элементы
    

## Deque

Наследник интерфейса Queue, представляющий собой АТД двунаправленная очередь, в которой элементы можно добавлять, удалять и получать как в начало, так и в конец. По сути работает как Stack и Queue одновременно

  

|   |   |   |   |   |
|---|---|---|---|---|
||First Element (Head)|   |Last Element (Tail)|   |
|Throws exception|Special value|Throws exception|Special value|
|Insert|addFirst(E)|offerFirst(E)|addLast(E)|offerLast(E)|
|Remove|removeFirst()|pollFirst()|removeLast()|pollLast()|
|Get|getFirst()|peekFirst()|getLast()|peekLast()|

  

Одной из реализаций является LinkedList

### ArrayDeque

Хранит элементы в массиве и индексы первого и последнего элементов: head и tail.

![](https://lh7-us.googleusercontent.com/u67Fww7RrbXC_2YYjYcGqHG5Rw8g25aEzmYHLBgWkk1OytA-PRjgi4_Fi77DSSpDk13WcikDnZuGgDiPJhUyzFlCBT8pJy0FC2Ee_ot_r-5Js0ij4jJBVjsNLOoNspJWVg8DJTzv8cQgCcMg8l608Hg)

- Дефолтный размер: 16
    
- Не поддерживает null-элементы
    
- Работает быстрее, чем Stack (потому что он synchronized, т.к. наследует Vector)
    
- Быстрее, чем LinkedList, т.к. элементы расположены ближе в памяти 
    

## Map

Предоставляет функционал по работе с данными вида “ключ - значение” (не наследуется от интерфейса Collection). Элементы хранятся в виде объекта Entry с двумя полями: ключ и значение

### HashMap

Реализация HashMap основана на Binned (bucketed) hash table.

Элементы хранятся в массиве Node’ов:

![](https://lh7-us.googleusercontent.com/2EIogrO3sUJ6INUyZerfKh8QHKH6D1tvfYWB81de4wzDWSmJysQBen5h_42h1525OpmBr1t-d_r-4WvNqLe_4UVYaZRQB839tQVP-zOYPjevHJ9r0nXks_U70-XUz0oN6VQf0PjE4lA2bAA-ppNpg_A)

где 

- hash - хэш ключа
    
- key - ключ
    
- value - значение
    
- next - следующее значение в bucket (По сути каждый bucket хранит в себе односвязный список) 
    

  

!!! Хеш-отображение не гарантирует порядок расположения своих элементов. Следовательно, порядок, в котором элементы вводятся в хеш-отображение, не обязательно соответствует тому порядку, в котором они извлекаются итератором. 

  

Важные поля:

- дефолтное capacity: 16
    
- load factor: 0.75 - коэффициент, который указывает при заполненности таблицы насколько следует ее увеличивать (дефолт 75% от capacity)
    
- threshold: предельное количество элементов в таблице, при достижении которого ее размер увеличивается вдвое: считается как capacity load factor
    
- table - представление хэш-таблицы в виде массива нодов Node<K, V>[]. Данное поле не инициализируется в конструкторе: только методом resize
    
- entrySet - кэшированый Set Map.Entry для прохода по мапе
    

  

Перестройка бакета

Если в хэш-таблице как минимум 64 бакета, то если новый добавляемый элемент становится 8 в бакете, то этот бакет преобразуется в древовидную структуру (красно-чёрное дерево).

Если количество элементов в древовидном бакете становится 6, то бакет обратно преобразуется в связный список.

Если добавляемый элемент в бакете становится 8, а количество бакетов меньше 64, то размер таблицы увеличивается и пересчитываются положения ее элементов (поскольку теперь больше вариантов для вставки элементов)

  

Добавление элемента

1. Вычисляется хэш ключа (! Поддерживает null ключи)
    
2. Вычисляется индекс бакета на основе хеша, в который будет добавлен Node
    
3. Добавление Node’а в бакет:
    

1. Если в бакете пусто, то Node просто добавляется
    
2. Если не пусто, то происходит проход по элементам бакета и элемент, у которого ключ совпал по хэшу или хэшу и по equals со вставляемым, перезаписывается
    
3. Если элемента с одинаковым ключем не нашлось, то Node вставляется в конец
    

  

Структура бакета при древовидной структуре:

![](https://lh7-us.googleusercontent.com/u2akuevOKF701D1-tbnMcbu5GcD13qMWYzJG2EA4WrNQAqRKHwoOXjywtp-0dDZkHb_Q_1b4RPB13w2Wm6Ggf-fs8pfr6Q-6GB0y3MhTDb87KqbW-sWDrXCzNlTXEJQeVZJu4wZLhHcrYOGxdx6bzzc)![](https://lh7-us.googleusercontent.com/rivEg7XR_ThfkydKoAkDp1t9lAe3AyKvBpvnNAV4STicAKU-oqCjUMT9HVpBSKCrV-VIR7-u6hM6D7q2hOkAmkrmifFgqn-u_WmsinC3-EQcqHM61PrTR3SPWIFFs9wnZeMzTj4xIBUCWKkap7Envgs)

Получение / удаление элемента по ключу

1. Вычислить хэш ключа
    
2. Вычислить индекс бакета
    
3. Сравнивать Node’ы элементов бакета по очереди по хэшу и если равны по equals
    
4. Если элемент найден - получаем / удаляем
    
5. Если элемент не найден возвращается null
    

  

Основной недостаток

Эффективность операций над HashSet’ом напрямую зависит от его размера (capacity). Чем больше capacity - тем больше бакетов с одним элементом.

### LinkedHashMap

Наследник HashMap, а следовательно наследует и его поля, однако помимо хранения хэш-таблицы хранит также ноды в виде связного списка (head и tail и каждый Node хранит Node’ы соседей), что обеспечивает фиксированный порядок.

! Поддерживает null ключи

  

Поддерживает два порядка итерации по элементам, контролируемых полем accessOrder:

1. Insertion-Order (по умолчанию) - итераци в порядке добавления элементов
    
2. Access-Order - итерация в порядке, в котором к элементам обращались в последний раз: то есть в последнем индексе будет элемент, к которому последнему обращались
    

### WeakHashMap

Аналог HashMap, но хранит ключи как WeakReference (Слабые ссылки, которые удаляются GC если на них никто не ссылается)

  

Пример:

![](https://lh7-us.googleusercontent.com/XnMD2g3NJ-M1d8jJLxVjq8Udz4mRGxyIJdmVvIKFBnieFaH1gjw4qC9ZxHHutaJvDurG6WwklfuhKwMe0AAaDoWc4bvaXAustEOSPlVXpC6rAc84DFo9oh39Vt-GGREdNBKFHXXk8kLK1ZtvzaBFj94)

Код выше выведет:

WeakHashMap size: 0

HashMap size: 1

### TreeMap

Реализация Map, элементы в которой хранятся как красно-чёрное дерево и отсортированы в естественном порядке ключей (реализуют Comparable) или при помощи компаратора.

  

Порядок помогает выполнять различные операции сравнения типа: найти самый большой / маленький ключ, все ключи меньше / больше определенного.

  

! null ключи поддерживаются только в тех TreeMap, где это поддерживает компаратор ключей

## Set

Представляет множество уникальных элементов с возможностью проверки наличия элемента в множестве, вставкой, удалением и базовыми операциями над множествами.

### HashSet

- хранит элементы как ключи в HashMap: HashMap<E,Object> map
    
- не сохраняет порядок элементов
    
- значением для map является пустой Object, который передается во все элементы как value
    
- дефолтный capacity = 16
    
- дефолтный loadFactor = 0.75
    

### LinkedHashSet

Наследует HashSet и при создании передает в package-private конструктор параметр dummy = true, который говорит HashSet’у использовать в качестве map реализацию LinkedHashMap.

### TreeSet

Хранит элементы как NavigableMap, где в качестве реализации используется TreeMap.

# Виды ссылок

- Strong Reference - сильные ссылки (тип ссылки по умолчанию). Объекты, на которые есть сильные ссылки не очищаются GC
    
- Weak Reference - слабые ссылки. Объекты, на которые есть только слабые ссылки, очищаются GC. Такие ссылки создаются классом WeakReference
    
- Soft Reference - мягкие ссылки: удаляются GC только если ему не хватает памяти и нет сильных ссылок
    
- Phantom Reference - фантомные ссылки: при сборке мусора у объекта на которые есть только фантомные ссылки вызывается finalize и он помещается в очередь ссылок ReferenceQueue. Объект очищается GC только когда он пропадает из этой очереди ссылок.
    

# Exceptions

[https://javastudy.ru/interview/exceptions/](https://javastudy.ru/interview/exceptions/) 

![](https://lh7-us.googleusercontent.com/GtUStT0yNAKUG9-T_984xVnwHlPMtReRlvME1KHaipiPAKQRBz1eKKv5xT46D3SwyTAKg_BvRGYi_CThUylJv1BKm4vEUr-xzk7BBEunfH7_PHU3BxeJCaN1KPq3K8h2H6S2auVzsGuG-_KLsQ1vjqY)

 Все исключительные ситуации делятся на «проверяемые» (checked) и «непроверяемые» (unchecked).

  

Исключения делятся на несколько классов, но все они имеют общего предка — класс Throwable. Его потомками являются подклассы Exception и Error.

  

Exceptions - являются результатом проблем в программе, которые в принципе решаемы и предсказуемы. Например, произошло деление на ноль в целых числах.

  

Errors - представляют собой более серьезные проблемы, которые, согласно спецификации Java, не следует пытаться обрабатывать в собственной программе, поскольку они связаны с проблемами уровня JVM. Например, исключения такого рода возникают, если закончилась память, доступная виртуальной машине. Программа дополнительную память всё равно не сможет обеспечить для JVM.

  

— Throwable и Exception и все их наследники (за исключением наследников Error-а и RuntimeException-а) — checked

— Error и RuntimeException и все их наследники — unchecked

  

## Checked / Unchecked

В Java все исключения делятся на два типа: контролируемые исключения (checked) и неконтролируемые исключения (unchecked), к которым относятся ошибки (Errors) и исключения времени выполнения (RuntimeExceptions, потомок класса Exception).

  

Checked exceptions представляют собой ошибки, которые можно и нужно обрабатывать в программе, к этому типу относятся все потомки класса Exception (но не RuntimeException).

Есть 2 варианта работы с такими исключениями:

1. Обработка в конструкциях try - catch - finally / try-with-resources
    
2. Пробросить исключение вне метода при помощи его указания в сигнатуре метода после ключевого слова throws.
    

  

Исключение можно пробрасывать при помощи throws вверх по иерархии вызовов методов вплоть до main.

Примеры: IOException, ServletException, SQLException и т.п.

  
  

Разница между ними в том, что обработку checked исключений проверяет компилятор. Вызывающий код обязан обработать такое исключение в блоке catch или передать дальше.

  

Рекомендуется использовать checked исключения для ситуаций, когда есть основания полагать, что вызывающий код способен выполнить восстановление, а unchecked исключения для указания на программные ошибки.

  

Существует строго соблюдаемое соглашение о том, что ошибки зарезервированы при использовании JVM, поэтому лучше не создавать новых подклассов Error и не генерировать их.

  

Преколы!!!!

- В multi-catch классы исключений не должны пересекаться(не должно быть предков и потомков, например IOException и FileNotFoundException  
      
    
- всегда можно в последнем catch ловить Exception
    
- Можно напугать в throws исключением которое не кидается
    
- Можно в throws указать родительское исключение, дочернее нельзя 
    

## Обработка исключений

Обработка исключений осуществляется при помощи конструкции try-catch-finally.

  

try - блок, в котором размещается код, который может бросить исключение

! try может быть без catch, но в таком случае блок finally обязателен

  

catch - блок, отлавливающий исключения

- Для обработки нескольких исключений в одном блоке catch используется оператор ‘|’
    
- Порядок исключений в блоках catch должен идти от наследников к родителям (сначала обработка IOException, а потом Exception)
    

  

finally - необязательный блок, код в котором выполнится независимо от того, будет ли отловлено исключение или нет.

! блок finally не будет вызван если прерывается поток, в котором он выполняется

  

- Если оператор return есть и в catch и в finally, то будет выполнен тот, что в finally
    
- Если в try выпало исключение и выполнение переместилось в finally, в котором также бросается исключение, то будет брошено исключение из finally.
    

  

throws - ключевое слово, пробрасывающее обработку исключение методу, который вызвал

- Можно указать родительское исключение (более общее)
    
- Можно указывать исключение, которое по факту не бросается
    
- Можно указывать unchecked исключения (используется для указания пользователям на конкретную ситуацию)
    
- При Overriding’е метода список исключений в throws у потомка не должен быть сильнее (более общим), чем у предка
    

  

try-with-resources - конструкция, введенная в Java 7 версии для автоматического закрытия ресурсов, объявленных в круглых скобках блока try. Данная конструкция упрощает закрытие потоков, которые до этого закрывались в блоке finally.

- Ресурс должен реализовывать интерфейс AutoCloseable
    
- Блоки catch и finally необязательны
    
- Можно объявить несколько ресурсов в одном try, разделив их точкой с запятой
    
- Ресурсы, открытые первыми, будут закрыты последними
    
- Начиная с Java 9 можно передавать final или effectively final ресурсы в блок try
    

# Generic

## Инвариантность, ковариантность, контравариантность

Инвариантность - отсутствие наследования между производными типами (например: тип List<String> НЕ является подтипом List<Object>)

Ковариантность - сохранение иерархии наследования исходных типов в производных типах в том же порядке (например: тип List<String> ЯВЛЯЕТСЯ подтипом List<? extends Object>, т.к. String является подтипом типа Object)

Контравариантность - обращение иерархии исходных типов на противоположную в производных типах (например: тип List<? super Object> ЯВЛЯЕТСЯ подтипом List<String>)

  

* Массивы в Java КОВАРИАНТНЫ

  

## PECS

 (Producer extends Consumer super) - при использовании wildcard (?)

- если он наследуется от типа (Producer), то не может использовать методы, в параметры которых передается этот generic тип, т.к. не известно с каким именно типом работает объект.
    
- если он является предком типа (Consumer), то МОЖЕТ использовать методы, в параметрах которых НЕТ generic типа, но будет возвращать объект типа Object, как базовый предок для всех.
    

![](https://lh7-us.googleusercontent.com/dR62nigOLx4WK2MIN-KRVntiV27_E7LrUmdXxFz9eDWp9npcm6SE26gEuZISb-zIs8Gajdt0FVgN8zFnvoSYT_xemYG9EnEg6sgF1TopSJHrm50x5jIGMdMvrIklngCp_SHTwkyRQfSfMDr8Dmwiyng)

У Producer’а, предположим, List<? extends Foo>, нельзя вызвать методы add() или set() этого объекта. Но это не значит, что объект является неизменяемым: например, ничто не мешает вам вызвать метод clear() для того, чтобы очистить список, так как clear() не имеет аргументов.

  

Единственное, что гарантируют маски (или другие типы вариантности) — безопасность типов.

# ООП

## Принципы

1. Инкапсуляция - скрытие внутренней реализации объекта от внешнего мира, чтобы защитить его от непреднамеренного изменения и обеспечить более простой интерфейс взаимодействия. Пример: создание класса «Студент», который имеет скрытые поля «имя», «возраст», «группа», а также публичные методы «получить имя», «получить возраст», «получить группу», «установить имя», «установить возраст», «установить группу». Это позволяет скрыть детали реализации и защитить данные студента от изменения извне.
    
2. Наследование - возможность создавать новые классы на основе уже существующих классов, чтобы переиспользовать код и добавлять новую функциональность.  
    Пример: создание класса «Автомобиль», который наследует свойства и методы от базового класса «Транспорт». Это позволяет переиспользовать код и добавлять новую функциональность к уже сущестgвующим объектам.
    
3. Полиморфизм - возможность объектов с одним и тем же интерфейсом выполнять разные задачи. Это может быть достигнуто через перегрузку методов, интерфейсы или абстрактные классы.  
    Пример: создание класса «Фигура», который имеет метод «площадь». Дочерние классы, такие как «Круг», «Квадрат», «Треугольник», могут переопределять метод «площадь» для выполнения разных задач в соответствии с типом фигуры.
    
4. Абстракция - определение объекта в терминах его свойств и методов, в то время как скрытие деталей реализации. Это позволяет создавать более абстрактный и универсальный код, который может быть использован в различных сценариях.  
    Пример: создание класса «Клиент», который имеет методы «вход» и «выход». Реализация методов может скрывать детали, такие как способ аутентификации клиента или время, которое он провел в системе, обеспечивая более абстрактный и универсальный код.
    
5. Ассоциация - когда один объект может содержать в себе другой в качестве одного из полей. Ассоциация описывается словом “имеет”: “Car имеет engine”.
    

Есть два вида ассоциации:

- Композиция - объект, который содержится в другом классе, не может существовать без него. Пример: экземпляр класса Engine создается в конструкторе Car без параметров. То есть созданием объекта Engine управляет класс Car.
    
- Агрегация - обратно композиции: объект может существовать самостоятельно и передается в другой при помощи параметра конструктора / сетера. 
    

## Проблемы множественного наследования

В Java множественное наследование не реализовано в привычном виде, однако поддерживается реализация множестве интерфейсов. Множественное наследование имеет следующие проблемы:

### Проблема ромба (Diamond problem)

К примеру, классы A, B и C определяют метод print_letter(). Если print_letter() будет вызываться классом D, неясно какой метод должен быть вызван — метод класса A, B или C.![](https://lh7-us.googleusercontent.com/ZTq8VXb0HfkUHHeLdq8yjon4AOBQ8LdoB11aBTNyHsJHuCum50XCfF0riaRyI6G2ClOs8uAOg_8SseOdwx1vp3KJWzeCg_9OXN502KILauNj7vACd6cYFJ_tjL9uc3DWt2M-r1XVCwOJ5u6nG6eyQpg)

  

Ромбовидная проблема — прежде всего проблема дизайна, и она должна быть предусмотрена на этапе проектирования. На этапе разработки ее можно разрешить следующим образом:

  

- Вызвать метод конкретного суперкласса
    
- Обратиться к объекту подкласса как к объекту определенного класса (привести тип перед вызовом)
    
- Переопределить проблематичный метод в последнем дочернем классе (в примере D)
    

  

Кроме того, в такой ситуации конструктор класса А будет вызван дважды при создании класса В и С

### Проблема одинаковых сигнатур методов

Если класс наследует два класса, каждый из которых содержит метод с одинаковой сигнатурой происходит проблема вызова такого метода из класса-наследника. Компилятор не поймет какой именно метод должен быть вызван.

  

В Java запрещена реализация двух интерфейсов, имеющих default-методы с одинаковыми сигнатурами без переопределения таких методов в классе-наследнике.

  

## SOLID

1. S - Single Responsibility Principle - принцип единственной ответственности. Каждый класс должен иметь только одну зону ответственности.
    
2. O - Open closed Principle - принцип открытости-закрытости. Классы должны быть открыты для расширения, но закрыты для изменения.
    
3. L - Liskov substitution Principle - принцип подстановки Барбары Лисков. Должна быть возможность вместо базового (родительского) типа (класса) подставить любой его подтип (класс-наследник), при этом работа программы не должна измениться.
    
4. I -  Interface Segregation Principle - принцип разделения интерфейсов. Данный принцип означает, что не нужно заставлять клиента (класс) реализовывать интерфейс, который не имеет к нему отношения.
    
5. D - Dependency Inversion Principle - принцип инверсии зависимостей. Модули верхнего уровня не должны зависеть от модулей нижнего уровня. И те, и другие должны зависеть от абстракции. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.
    

## Принципы разработки

### YAGNI

You Aren’t Gonna Need It - при написании кода нужно быть уверенным, что он понадобится. Применим при рефакторинге, когда нужно не боятся удалять неиспользуемые методы, а если в будущем они понадобятся - найти их через git.

### DRY

Don’t Repeat Yourself - не повторять код, написанный ранее и переиспользовать его. Связано с концепцией SSOT.

### SSOT 

Single Source Of Truth - практика структурирования системы и схемы данных, которая подразумевает, что все данные обрабатываются в одном месте. 

### KISS

Keep It Simple, Stupid - чем проще система - тем она лучше и надежнее. Это также означает, что не нужно придумывать задаче более сложное решение, чем требуется.

### BDUF

Big Design Up Front - глобальное проектирование прежде всего, что означает, что прежде чем переходить к реализации необходимо все тщательно продумать.

### APO

Avoid Premature Optimization - избегайте преждевременной оптимизации. То есть не нужно оптимизировать решение, если в данный момент в оптимизации нет необходимости. Следование этому принципу сокращает время вывода приложений на MVP.

### FIRST

5 характеристик, которыми должны обладать тесты:

Fast: тесты должны выполняться быстро, чтобы их было удобно часто запускать

Independent: тесты не должны зависеть друг от друга. Один тест не должен создавать условия для выполнения другого.

Repeatable: тесты должны давать одинаковый результат независимо от среды выполнения и количества выполнений

Self-Validating (очевидность): результатом выполнения теста должен быть логический признак: прошел или нет

Timely (своевременность): тесты должны создаваться своевременно: непосредственно перед написанием кода, обеспечивающего его выполнение

  

## Immutable class

  

Immutable class - класс, который после инициализации не может изменить свое состояние. То есть если в коде есть ссылка на экземпляр иммутабельного класса, то любые изменения в нем приводят к созданию нового экземпляра.  
  

Условия:

- Должен быть final, чтобы дочерние классы не нарушили иммутабельность;
    
- Все поля приватные, для соблюдения инкапсуляции;
    
- Наличие параметризированных конструкторов, для инициализации полей;
    
- Отсутствие setter’ов, для невозможности менять состояние извне;
    
- Глубокие копии полей-коллекций, для гарантии их неизменности.
    

  

### String

Класс String immutable, что дает ему преимущества:

- Потокобезопасность;
    
- Возможность использовать область памяти пул строк, которая позволяет при использовании двух разных переменных с одинаковым значением ссылать на одну область памяти;
    
- Хорошо подходят в качестве ключей в коллекциях, т.к. гарантируют неизменность ключа по ссылке;
    
- Кэширует хэш-код, что улучшает производительность хеш-коллекций, использующих String.
    
- Чувствительные данные, такие как имена пользователей и пароли, нельзя изменить по ошибке во время выполнения, даже при передаче ссылок на них между разными методами.
    

Все классы-обертки над примитивами также immutable.

# Архитектура

## Cohesion

Cohesion - степень связи элементов внутри модуля друг с другом.

Модуль с high cohesion содержит элементы, тесно связанные друг с другом и объединенные своим назначением. 

Модуль с low cohesion содержат несвязанные друг с другом по назначению элементы.

![](https://lh7-us.googleusercontent.com/vPTBqC-oe8COcusINb9M97r48o9APjU90NmlM6HuEo_Z4kKwMs0rMUbupfgunWHux2PsaxF-7jjGOm6VecPuD8SRaN_-ZSdMfPP-mlZyU-7ngQ_Sd1w8oVCoqaFI2Nc5xzoy8HYLR_y8riiVSYxKOd4)

Эта концепция связана с Single Responsibility Principle: класс должен иметь одну ответственность. 

Преимущества high cohesion:

- Модули легки для понимания и более читабельны;
    
- Легче производить изменения в коде;
    
- Проще тестировать код;
    

## Coupling 

Coupling - степень взаимозависимости между программными модулями. Связь заключается в том, что изменение одного требует изменения другого.

![](https://lh7-us.googleusercontent.com/vs-oXJ_MNMaVL-jFXmQsWwmij92nhn6bn6g6uHTQmNu6ZmUCrl6eER4KyccyFy5fR9x-9_9nKbajJ66xsoM96RGoacmeghCDrLj1ppNPbHATkJ3FCSBLyTxmTOgkNh3X0h9biS3cKXe_73sDtv7gzSk)![](https://lh7-us.googleusercontent.com/ssZibqZUpi5OTiBLbrf1qSLg0-mPmEtTFFRD7xCCkoNQh7wBVdLoHQ2R-Xh_dALOiLvDkMIGzDy4NfANKVC44yX4qwan4CQH89-ZfEQ5yx2kD60s6zcwwYiFVuLCI3CiVFxNlYKvgEXtM0Atm7TTPcQ)

Преимущества loose coupling:

- Сильно связанные модули трудны в изменении;
    
- Сильно связанные модули трудны в тестировании.
    

  

High cohesion коррелирует с loose coupling.

  

многоуровневая, гексагональная, луковая, чистая, DDD

Вид архитектуры, который определяет способ общения элементов друг с другом путем разделения приложения на слои (layers), которые используют порты для общения друг с другом.

## DDD

Domain Driven Design - архитектурный подход, задача которого - выделение бизнес логики (Domain) приложения и его изоляция. Domain слой не зависит от внешних библиотек, не привязан к источникам данных и не знает про детали реализации приложения (какая БД, какой кэш и т.п.)

## Многоуровневая архитектура

Разделение системы на отдельные уровни с организацией внутри них компонентов по соответствующим критериям. Каждый уровень - группа модулей, предоставляющих взаимосвязанный набор сервисов. Их применение должно быть однонаправленным. Уровни полностью разделяют ПО, причем каждая часть доступна через публичный интерфейс.

![](https://lh7-us.googleusercontent.com/Hn5p8hCISN5pwTrPCpf7_k3ti1q1GaAhB7iyo187PfR9gQNKDTPC5p9ue6vkdeXPoMVQnP18evJNCvvs1umBetgG1zUqBqNMEdWYD0XR2xDcuv7P86SoS2ag5JqAIARwy6CvyqGwSWHhDpDCvi6vXLw)

Эта архитектура способствует применению high cohesion loose coupling.

Классический пример многоуровневой архитектуры - трехуровневая:

1. view layer - UI; 
    
2. Business logic layer - реализация бизнес-сценариев, независим от View layer;
    
3. Data access layer - взаимодействие с источниками данных (БД, REST и т.п.)
    

## Гексагональная архитектура

![](https://lh7-us.googleusercontent.com/xeeOXYJqarVLAr8Bv3lEVnlqT1gjugMfrnSVw-IXrvAvH_78ZWbpPaRV59aA2Wdcy022WBsij7IgX1PEx-E7G38ScTD4FBQbHnRkilyJK2XcemY46kNDjvZufePBrpQUluZwxdabQC1NnFJQBEE2vKc)

Вид архитектуры, который определяет способ общения элементов друг с другом путем разделения приложения на слои, которые используют порты (Интерфейсы) для общения друг с другом.

Использование портов позволяет не зависеть от реализации каждого слоя.

- Каждый слой имеет свое предназначение;
    
- Количество слоев ограничено потребностями проекта.
    

Основные компоненты гексагональной архитектуры:

Domain - бизнес-логика приложения, независимая от внешних зависимостей и проблем, таких как БД, MQ, и т.п. Он не должен знать про существование других слоев.

Порты - интерфейсы, определяющий контракт взаимодействия между логикой домена и внешними сервисами. Они отвечают за определение форматов ввода/вывода и протоколов взаимодействия между приложением и его адаптерами. 

Порты бывают:

- Управляющие - используются внешними клиентами для взаимодействия с нашим приложением.
    
- Управляемые - используются нашим приложением для взаимодействия с внешними сервисами.
    

Адаптеры - отвечают за реализацию портов: переводят внешнее представление данных и функциональности в формат, понятный приложению.

Адаптеры разделяют на:

- Ведущие - преобразуют внешние данные в команды и запросы, понятные домену.
    
- Управляемые - преобразуют выходные данные и требования бизнес логики в вызовы и операции для внешних сервисов.
    

Infrastructure - слой, работающий со сторонними библиотеками и фреймворками.

## Clean architecture

![](https://lh7-us.googleusercontent.com/fXsYsMh3A9RXtWgHSBuzpd32S6-wx7CtXuI_CXr-xYC9VpddNkOQkJS46yUyNaG1uYCRI-f-jlttAQOJbMXooQ2oeLTdqhhL5K3KGjsKH64_oncXa3Xb7nEO5gDaecq1OX4NJ_8_SlDF44svs1mcar4)

Правило зависимостей - зависимости в исходном коде могут указывать только во внутрь.

  

Сущности - бизнес-правила. Могут быть объектами с методами или структурами данных. Внешние изменения не должны влиять на слой сущностей.

  

Сценарии - реализация специфики бизнес-правил. Инкапсуляция всех случаев использования системы. Реализуют поток данных в и из слоя Сущностей. При этом при изменении поведения приложения они затронут этот слой.

  

Интерфейс-Адаптеры - набор адаптеров, преобразующих данные из формата наиболее удобным для Сценариев и Сущностей, в формат удобный для дальнейшего использования и наоборот.

  

Фреймворк и драйверы - состоит из фреймворков, БД, UI и т.д.

  

## MVC

# SQL

## Транзакции

### ACID

- Atomicity (Атомарность) - каждая транзакция будет выполнена полностью или не выполнена совсем;
    
- Consistency (Консистентность) - транзакции не должны нарушать консистентность БД - отсутствие недопустимых состояний;
    
- Isolation (Изолированность) - во время выполнения транзакции параллельные транзакции не должны оказывать влияния на её результат;
    
- Durability (Надежность) - гарантия что результат выполнения транзакции сохранится в случае сбоя системы.
    

### Уровни изоляции

- Read uncommitted - самая низкая согласованность данных, но самая высокая скорость. Каждая транзакция видит незафиксированные другой транзакцией изменения (грязное чтение);
    
- Read committed - транзакция видит изменения, зафиксированные другой транзакцией (неповторяющееся чтение, чтение фантомов);
    
- Repeatable read - не видны измененные и удаленные записи другой транзакции, но видны вставленные ей строки (чтение фантомов);
    
- Serializable - транзакции не видят действий друг друга.
    

### Феномены изоляции

- Грязное чтение - если транзакция видит незафиксированные изменения другой, то в случае отката она будет видеть неактуальные данные;
    
- Неповторяющееся чтение - видны измененные и удаленные другой транзакцией записи;
    
- Чтение фантомов - видны добавленные другой транзакцией записи.
    

## JOIN

![](https://lh7-us.googleusercontent.com/jLc7KzH_2tPFoNHtn8zaS2XSjFzLUAcR8W2Jr5oVe1nyaGAPAk6XJFEjSOMwYzG0GQzoWX0OHCLSYMTHTi8Jfn2oSYl4gnOqmzm4xw2Wkn7nKe1yj-4QqExVmS0R69JtDBOn16doKbYQtEcXV5sLiXc)

# WEB

![](https://lh7-us.googleusercontent.com/H4n0rAGyzWh7pGJGbECWG_xTgdJmQzQzPV_AtfaPXszyMadFpDULEd7MsvOPBorwk4CWAonNuRHDyw8VtqpjU0SQ4-KxvAP1xQr1ieXP4cY6IVeZmD1-MnCgEd1PtXJcaP7x2Qs1dpy4TyybDh_TdD0)

![](https://lh7-us.googleusercontent.com/x35tJNQ8cxAM75stnWFPg9HkqQ0eM--I8VyMFpy4E7Tau_d9bEa6117O8R35sMBubkJODfKeNFn5B3i1rYpQHeQ0DZHuhs-c2wvm31beHscOWbSm1py15--wDEM7MzYsiZC0Fi3S_N_VnxZRiGoKwto)

![](https://lh7-us.googleusercontent.com/mdY30QJ7yMhR8A09Jf4pqIoq4IS0Eb8CiN2KAKpCBzQj9mD5TwrFL5TmCyJ2W5EhPzJDIXLJniLWvGpGk5raP86eIm79jcnxa70PpblmMRNu2qtWhiP-MdGMKApSDjpnFzi22iXb8fhLwt-KJvl6iAI)**